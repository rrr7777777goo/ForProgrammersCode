## 알고리즘 복잡도 : O(n^2)

### 버블 정렬 (Bubble Sort)
- 인접한 데이터를 비교하며 자리를 바꾸는 방식

### 삽입 정렬 (Insertion Sort)
- 앞의 데이터를 정렬해가면서 삽입 위치를 찾아 정렬하는 방식

### 선택 정렬 (Selection Sort)
- 최소 때는 최대 값을 찾아서 가장 앞 또는 뒤부터 정렬하는 방식

### 퀵 정렬 (Quick Sort)
- 임의의 기준 값을 정하고 그 값을 기준으로 좌우로 분할 정렬하는 방식

### 셸 정렬 (Shell Sort)
- 삽입 정렬의 약점을 보완한 정렬 방식
  
- 삽입 정렬의 약점 (오름차순 정렬 기준, 내림차순으로 구성된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요)
  
- 이전의 모든 데이터와 비교하지 않고 일정 간격을 두어 비교
  
- 알고리즘 복잡도 자체는 삽입 정렬과 동일하지만 일반적인 산포 데이터 기준으로는 삽입 정렬에 비해 빠르다.   

##

<br/>

## 알고리즘 복잡도 : O(nlogn)

### 합병 정렬 (Merge Sort)
- 배열을 계속 분할해서 길이가 1이 되도록 만들고 인접한 부분끼리 정렬하면서 합병하는 방식

### 힙 정렬 (Heap Sort)
- 힙 자료구조 형태의 정렬 방식
  
- 기존 배열을 최대 힙으로 구조 변경 후 정렬 진행

### 트리 정렬 (Tree Sort)
- 이진탐색트리(BST)를 만들어 정렬하는 방식

##

<br/>

## 알고리즘 복잡도 : O(dn) (여기서 d는 최대 자릿수를 의미한다.)

### 기수 정렬 (Radix Sort)
- 낮은 자리 수 부터 정렬하는 방식
  
- 각 원소간의 비교 연산을 하지 않아 빠른 대신, 기수 테이블을 위한 메모리 필요
##

<br/>

## 알고리즘 복잡도 : O(n+k) (여기서 k는 정렬 대상 데이터 중 최대값을 의미한다.)

### 계수 정렬 (Counting Sort)
- 숫자끼리 비교하지 않고 카운트를 세서 정렬하는 방식
  
- 카운팅을 위한 메모리 필요
##
